<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TaoLe</title>
  
  
  <link href="https://example.com/atom.xml" rel="self"/>
  
  <link href="https://example.com/"/>
  <updated>2025-02-26T13:02:05.943Z</updated>
  <id>https://example.com/</id>
  
  <author>
    <name>taole</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LC_20250226</title>
    <link href="https://example.com/2025/02/26/LC-20250226/"/>
    <id>https://example.com/2025/02/26/LC-20250226/</id>
    <published>2025-02-26T01:40:51.000Z</published>
    <updated>2025-02-26T13:02:05.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LC-70"><a href="#LC-70" class="headerlink" title="LC_70"></a>LC_70</h2><blockquote><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><p><strong>解法一</strong></p><ul><li>思路 ：利用<code>dp</code>数组存储到达每一级台阶的方法数</li><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义dp数组用于存储每层台阶的方法数</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="comment">// 第0阶的方法数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第一阶的方法数</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong></p><ul><li>思路：在实际计算中，我们只用到了当前台阶和前两级台阶的方法数，所以可以把<code>dp</code>数组转化为变量存储，优化空间复杂度</li><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// n-2层台阶的方法数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// n-1层台阶的方法数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> pre + bp;</span><br><span class="line">            bp = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-746"><a href="#LC-746" class="headerlink" title="LC_746"></a>LC_746</h2><blockquote><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p></blockquote><p>解法一</p><ul><li>思路：通过<code>dp</code>数组记录到达每层的最少费用，状态转移方程为<code>dp[i] += Math.min(dp[i-1],dp[i-2])+cost[i]</code>,到达第n层可能是从<code>n-1</code>或者<code>n-2</code></li><li>时间复杂度<code>O(n)</code></li><li>空间复杂度<code>O(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">// 用dp数组存储每层楼梯的费用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化dp数组</span></span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp方程 dp[i] = Math.min(dp[i-1],dp[i-2])+cost[i];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第n层可能从n-1层或者n-2层到达，取最小值</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[n-<span class="number">1</span>],dp[n-<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二</p><ul><li>思路：在解法一的基础上进行空间优化，把dp数组换为常量</li><li>时间复杂度<code>O(n)</code></li><li>空间复杂度<code>O(1)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">bp</span> <span class="operator">=</span> cost[<span class="number">0</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> cost[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp方程 dp[i] += Math.min(dp[i-1],dp[i-2])+cost[i];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> Math.min(pre,bp) + cost[i];</span><br><span class="line">            <span class="comment">// 移动指针</span></span><br><span class="line">            bp = pre;</span><br><span class="line">            pre = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第n层可能从n-1层或者n-2层到达，取最小值</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(bp,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-377"><a href="#LC-377" class="headerlink" title="LC_377"></a>LC_377</h2><blockquote><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>&#x2F;&#x2F; 本题可以看为爬楼梯的变式 每次爬1&#x2F;2层–》每次爬取<code>num</code> 层，<code>num</code>为<code>nums</code>中所有可能取值</p></blockquote><ul><li>思路：每个元素可以使用多次，定义<code>dp</code>数组，表示实现总和为<code>target</code>需要<code>dp[i]</code>个数,对于<code>dp[i]</code>需要计算所有<code>dp[i-num]</code>之和，所以状态转移方程为<code>dp[i] += dp[i - num]</code></li><li>时间复杂度：<code>O(target * n)</code></li><li>空间复杂度：<code>O(target)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// dp数组表示总和为i需要dp[i]个数</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 状态转移方程 dp[i] += dp[i-nums[i]];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-2466"><a href="#LC-2466" class="headerlink" title="LC_2466"></a>LC_2466</h2><blockquote><p>给你整数 <code>zero</code> ，<code>one</code> ，<code>low</code> 和 <code>high</code> ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p><ul><li>将 <code>&#39;0&#39;</code> 在字符串末尾添加 <code>zero</code> 次。</li><li>将 <code>&#39;1&#39;</code> 在字符串末尾添加 <code>one</code> 次。</li></ul><p>以上操作可以执行任意次。</p><p>如果通过以上过程得到一个 <strong>长度</strong> 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <strong>好</strong> 字符串。</p><p>请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p></blockquote><ul><li>思路：定义两个状态转移方程，用于处理<code>zero</code>和<code>one</code>两种情况</li><li>时间复杂度<code>o(n)</code></li><li>空间复杂度<code>o(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        <span class="comment">// dp数组表示在i时的可能字符串数目</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[high+<span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp[i]的取值与zero和one的数量有关，如果 i&gt;zero--&gt;dp[i]+=dp[i-zero], i&gt;one dp[i]+=dp[i-one];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= zero) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - zero]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= one) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - one]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++) &#123;</span><br><span class="line">            result = (result + dp[i]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-198"><a href="#LC-198" class="headerlink" title="LC_198"></a>LC_198</h2><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p></blockquote><ul><li>思路：对于<code>dp[i]</code>,<code>dp[i] = Math.max(dp[i-1],dp[i-2]+num[i])</code>;</li><li>时间复杂度<code>O(n)</code></li><li>空间复杂度<code>O(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i] 表示进入第i家窃取的最高现金</span></span><br><span class="line">        <span class="comment">// 初始化dp[0],dp[1];</span></span><br><span class="line">        <span class="comment">// 状态转移方程 dp[i] = Math.max(dp[i-1],dp[i-1]+nums[i])</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-740"><a href="#LC-740" class="headerlink" title="LC_740"></a>LC_740</h2><blockquote><p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p><p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p></blockquote><p>解法一</p><ul><li>思路：通过HashMap过滤数组，从而转化为rob问题</li><li>时间复杂度<code>O(m+n)</code></li><li>空间复杂度<code>O(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            countMap.put(num, countMap.getOrDefault(num, <span class="number">0</span>) + num); <span class="comment">// 累加值而非次数</span></span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划数组，dp[i] 表示到达 i 时能获得的最大操作数</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxNum + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = countMap.getOrDefault(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= maxNum; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + countMap.getOrDefault(i, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[maxNum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二</p><ul><li>思路：把原数组拆解，使得<code>sum[num] += num</code>，从而转化为rob问题</li><li>时间复杂度<code>O(n)</code></li><li>空间复杂度<code>O(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : nums) &#123;</span><br><span class="line">            maxVal = Math.max(maxVal, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[maxVal + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : nums) &#123;</span><br><span class="line">            sum[val] += val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rob(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> second;</span><br><span class="line">            second = Math.max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LC-70&quot;&gt;&lt;a href=&quot;#LC-70&quot; class=&quot;headerlink&quot; title=&quot;LC_70&quot;&gt;&lt;/a&gt;LC_70&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫学习笔记一</title>
    <link href="https://example.com/2025/02/26/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>https://example.com/2025/02/26/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</id>
    <published>2025-02-26T01:13:46.000Z</published>
    <updated>2025-02-26T01:14:31.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h2><p>通过脚本语言模拟网络请求进行数据获取</p><h2 id="爬虫分类"><a href="#爬虫分类" class="headerlink" title="爬虫分类"></a>爬虫分类</h2><ul><li>通用爬虫</li><li>聚焦爬虫</li></ul><h2 id="http协议-https协议"><a href="#http协议-https协议" class="headerlink" title="http协议&#x2F;https协议"></a>http协议&#x2F;https协议</h2><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><p><code>scheme://host:port/path/query-string#anchor</code></p><ul><li>scheme : 协议名称</li><li>host：主机地址</li><li>port：端口号</li><li>path：路径</li><li>query-string：参数</li><li>anchor：前端锚点</li></ul><h2 id="请求头常用参数"><a href="#请求头常用参数" class="headerlink" title="请求头常用参数"></a>请求头常用参数</h2><ul><li><code>Accept</code>：通知服务器客户端可以处理的数据类型</li><li><code>Accept-Encoding</code>：指定客户端支持的编码格式</li><li><code>Accept-Language</code>：告知服务器客户端的偏好语言</li><li><code>Authorization</code>：提供访问资源所需的认证信息</li><li><code>Content-Type</code>：请求体中的数据格式</li><li><code>Content-Length</code>：请求体的长度，客户端自动设置</li><li><code>User-Agent</code>：标识发起请求的客户端软件，包括浏览器名称、版本号和操作系统</li><li><code>Referer</code>：指明当前页面是从哪个URL跳转过来的，对一些资源的权限访问有用</li><li><code>Origin</code>：跨域请求时，指示请求的来源协议、域名和端口号</li><li><code>Connection</code>：管理连接的状态</li><li><code>Host</code>指定请求主机的主机名和端口号</li><li><code>Cache-Control</code>控制缓存</li><li><code>If-Modified-Since</code>仅当资源自指定日期后被修改过时才返回资源，否则返回 304 Not Modified。</li><li><code>If-None-Match</code>与 <code>ETag</code> 一起使用，只有当 ETag 不匹配时才返回资源，否则返回 304 Not Modified。</li><li><code>Cookie</code>发送存储在客户端的 Cookie 到服务器。</li></ul><h2 id="豆瓣电影爬取"><a href="#豆瓣电影爬取" class="headerlink" title="豆瓣电影爬取"></a>豆瓣电影爬取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  </span><br><span class="line">    <span class="comment"># 获取url  </span></span><br><span class="line">    baseurl = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span>  </span><br><span class="line">    savePath = <span class="string">&quot;./豆瓣top250.xlsx&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 爬取网页并解析数据  </span></span><br><span class="line">    data_list = get_data(baseurl)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 保存数据到Excel文件  </span></span><br><span class="line">    save_data(data_list, savePath)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">baseurl</span>):  </span><br><span class="line">    headers = &#123;  </span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&quot;</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    data_list = []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):  <span class="comment"># 每页25部电影  </span></span><br><span class="line">        url = <span class="string">f&quot;<span class="subst">&#123;baseurl&#125;</span><span class="subst">&#123;i&#125;</span>&quot;</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            response = requests.get(url, headers=headers)  </span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:  </span><br><span class="line">                soup = BeautifulSoup(response.text, <span class="string">&#x27;lxml&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">                items = soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;item&#x27;</span>)  </span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> items:  </span><br><span class="line">                    movie_info = &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">                    title = item.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;title&#x27;</span>).get_text()  </span><br><span class="line">                    rating = item.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;rating_num&#x27;</span>).get_text()  </span><br><span class="line">                    description_tag = item.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;inq&#x27;</span>)  <span class="comment"># 可能为空  </span></span><br><span class="line">  </span><br><span class="line">                    movie_info[<span class="string">&#x27;title&#x27;</span>] = title  </span><br><span class="line">                    movie_info[<span class="string">&#x27;rating&#x27;</span>] = rating  </span><br><span class="line">                    movie_info[<span class="string">&#x27;description&#x27;</span>] = description_tag.get_text() <span class="keyword">if</span> description_tag <span class="keyword">else</span> <span class="string">&#x27;无&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">                    data_list.append(movie_info)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Failed to retrieve page <span class="subst">&#123;i&#125;</span>, status code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error occurred while fetching or parsing page <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> data_list  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">data_list, savePath</span>):  </span><br><span class="line">    df = pd.DataFrame(data_list)  </span><br><span class="line">    df.to_excel(savePath, index=<span class="literal">False</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Data saved successfully to <span class="subst">&#123;savePath&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是爬虫&quot;&gt;&lt;a href=&quot;#什么是爬虫&quot; class=&quot;headerlink&quot; title=&quot;什么是爬虫&quot;&gt;&lt;/a&gt;什么是爬虫&lt;/h2&gt;&lt;p&gt;通过脚本语言模拟网络请求进行数据获取&lt;/p&gt;
&lt;h2 id=&quot;爬虫分类&quot;&gt;&lt;a href=&quot;#爬虫分类&quot; class</summary>
      
    
    
    
    
    <category term="-python -爬虫" scheme="https://example.com/tags/python-%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>LC_20250225</title>
    <link href="https://example.com/2025/02/25/LC-20250225/"/>
    <id>https://example.com/2025/02/25/LC-20250225/</id>
    <published>2025-02-25T12:43:27.000Z</published>
    <updated>2025-02-25T13:42:43.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LC-1-两数之和"><a href="#LC-1-两数之和" class="headerlink" title="LC_1 两数之和"></a>LC_1 两数之和</h2><blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p></blockquote><ul><li>思路<ul><li>求n1+n2 &#x3D; target –&gt; 求存在target-n1</li></ul></li><li>时间复杂度<code>O(n)</code></li><li>空间复杂度<code>O(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target-nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,map.get(target-nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-2-两数相加"><a href="#LC-2-两数相加" class="headerlink" title="LC_2 两数相加"></a>LC_2 两数相加</h2><blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p></blockquote><ul><li>思路<ul><li>对两个链表求和，同时记录进位，填充结果链表，（要注意链表长度不等的情况），如果最后还有进位，添加一个节点</li></ul></li><li>时间复杂度<code>O(n)</code></li><li>空间复杂度<code>O(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化进位值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 创建一个虚拟头节点，方便处理结果链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历两个链表直到其中一个为空</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的值，如果链表已结束则默认为0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (l1 != <span class="literal">null</span>) ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (l2 != <span class="literal">null</span>) ? l2.val : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算当前位的和（包括进位）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry + x + y;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新进位值</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建新节点并连接到结果链表</span></span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动到下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最后还有进位，则添加一个新的节点</span></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果链表（跳过虚拟头节点）</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-1512-好数对的数目"><a href="#LC-1512-好数对的数目" class="headerlink" title="LC_1512 好数对的数目"></a>LC_1512 好数对的数目</h2><p>给你一个整数数组 <code>nums</code> 。</p><p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> &#x3D;&#x3D; <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p><p>返回好数对的数目。</p><ul><li>思路<ul><li>顺序遍历，存在<code>nums[i]== nums[j</code> 记录当前<code>nums[i]</code>的出现次数，因为后续每次遇到<code>nums[j]</code>都要重复计算</li></ul></li><li>时间复杂度<code>O(n)</code></li><li>空间复杂度<code>O(n)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIdenticalPairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 思路：hashMap遍历，如果存在nums[i]&lt;nums[j],计数加一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录返回结果</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                count+=map.get(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LC-1-两数之和&quot;&gt;&lt;a href=&quot;#LC-1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;LC_1 两数之和&quot;&gt;&lt;/a&gt;LC_1 两数之和&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记整理</title>
    <link href="https://example.com/2025/02/25/Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>https://example.com/2025/02/25/Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2025-02-25T12:23:37.000Z</published>
    <updated>2025-02-25T12:48:37.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><p>Redis本质：内存型键值对数据库</p><ul><li>基本数据类型<ul><li>String</li><li>Hash</li><li>List</li><li>Set</li><li>ZSet</li><li>特殊类型</li></ul></li><li>持久化机制<ul><li>RDB（快照）</li><li>AOF（追加日志）</li></ul></li></ul><hr><h2 id="Redis基本数据类型"><a href="#Redis基本数据类型" class="headerlink" title="Redis基本数据类型"></a>Redis基本数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a><strong>String（字符串）</strong></h3><p>🔑 <strong>数据结构</strong><br>二进制安全，可存储文本&#x2F;数字&#x2F;序列化对象，最大512MB</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>SET key value [EX seconds]</code> 设置带过期时间的值</li><li><code>GET key</code> </li><li><code>INCR/DECR key</code> 原子计数器</li><li><code>MSET/MGET</code> 批量操作</li><li><code>SETBIT/GETBIT</code> 位操作</li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>缓存HTML片段&#x2F;序列化对象</li><li>分布式锁（SETNX）</li><li>限流器（INCR+EXPIRE）</li><li>位统计（日活用户Bitmap）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>Value超过10KB需警惕大Key问题</li><li>INCR存在溢出风险（最大值9223372036854775807）</li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>动态字符串SDS（O(1)获取长度，预分配空间）</li><li>数值类型自动转int存储优化</li></ul><hr><h3 id="Hash（哈希表）"><a href="#Hash（哈希表）" class="headerlink" title="Hash（哈希表）"></a><strong>Hash（哈希表）</strong></h3><p>🔑 <strong>数据结构</strong><br>双向链表，元素可重复，按插入顺序排序</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>LPUSH/RPUSH key element</code></li><li><code>LPOP/RPOP key</code></li><li><code>BLPOP/BRPOP</code> 阻塞式弹出</li><li><code>LRANGE key start stop</code></li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>消息队列（结合BLPOP实现）</li><li>最新消息排行（LPUSH+LRANGE）</li><li>分页查询（LRANGE实现）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>长列表（元素数&gt;1000）查询性能下降</li><li>多个消费者场景需做消息ACK确认</li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>快速链表quicklist（ziplist+linkedlist结合）</li><li>节点元素上限可通过list-max-ziplist-size配置</li></ul><p>📌 <strong>实战技巧</strong>  </p><ul><li>使用<code>LTRIM</code>维护固定长度队列</li></ul><hr><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><strong>List（列表）</strong></h3><p>🔑 <strong>数据结构</strong><br>双向链表，元素可重复，按插入顺序排序</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>LPUSH/RPUSH key element</code></li><li><code>LPOP/RPOP key</code></li><li><code>BLPOP/BRPOP</code> 阻塞式弹出</li><li><code>LRANGE key start stop</code></li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>消息队列（结合BLPOP实现）</li><li>最新消息排行（LPUSH+LRANGE）</li><li>分页查询（LRANGE实现）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>长列表（元素数&gt;1000）查询性能下降</li><li>多个消费者场景需做消息ACK确认</li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>快速链表quicklist（ziplist+linkedlist结合）</li><li>节点元素上限可通过list-max-ziplist-size配置</li></ul><p>📌 <strong>实战技巧</strong>  </p><ul><li>使用<code>LTRIM</code>维护固定长度队列</li></ul><hr><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a><strong>Set（集合）</strong></h3><p>🔑 <strong>数据结构</strong><br>无序且元素唯一的集合，支持交并差运算</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>SADD key member</code></li><li><code>SISMEMBER key member</code></li><li><code>SINTER key1 key2</code> 交集</li><li><code>SUNIONSTORE dest key1 key2</code> 并集存储</li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>标签系统（用户标签集合）</li><li>共同关注（SINTER计算交集）</li><li>UV统计（去重计数）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>SMEMBERS全量获取可能阻塞，优先用SSCAN</li><li>超大集合（&gt;1W元素）交并运算消耗内存激增</li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>小集合用intset（整数数组）</li><li>大集合转为hashtable存储</li></ul><p>📌 <strong>实战技巧</strong>  </p><ul><li>使用<code>SPOP</code>实现随机抽奖功能</li></ul><hr><h3 id="ZSet（有序集合）"><a href="#ZSet（有序集合）" class="headerlink" title="ZSet（有序集合）"></a><strong>ZSet（有序集合）</strong></h3><p>🔑 <strong>数据结构</strong><br>唯一成员+排序权重（score）的有序结构</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>ZADD key score member</code></li><li><code>ZRANGE key start stop [WITHSCORES]</code></li><li><code>ZRANK key member</code> 获取排名</li><li><code>ZREVRANGEBYSCORE</code> 按分数范围查询</li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>实时排行榜（直播打赏排行）</li><li>延迟队列（score存执行时间戳）</li><li>范围查询（地理位置附近的人）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>Score使用双精度浮点数，存在精度丢失风险</li><li>大数据量范围查询优先用<code>ZSCAN</code></li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>ziplist（元素数&lt;128且value&lt;64字节时）</li><li>skiplist+dict组合结构（跳跃表维护顺序，字典快速查找）</li></ul><p>📌 <strong>实战技巧</strong>  </p><ul><li>使用<code>ZUNIONSTORE</code>实现多维度加权排序</li></ul><hr><h3 id="数据类型选择决策树"><a href="#数据类型选择决策树" class="headerlink" title="数据类型选择决策树"></a><strong>数据类型选择决策树</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[需要排序?] --&gt;|Yes| B(ZSet)</span><br><span class="line">    A --&gt;|No| C&#123;需要唯一性?&#125;</span><br><span class="line">    C --&gt;|Yes| D(Set)</span><br><span class="line">    C --&gt;|No| E&#123;数据结构形态?&#125;</span><br><span class="line">    E --&gt;|Key-Value| F(Hash)</span><br><span class="line">    E --&gt;|单值/计数器| G(String)</span><br><span class="line">    E --&gt;|队列/栈| H(List)</span><br></pre></td></tr></table></figure><hr><h3 id="对比表"><a href="#对比表" class="headerlink" title="对比表"></a><strong>对比表</strong></h3><table><thead><tr><th></th><th>唯一性</th><th>排序</th><th>时间复杂度</th><th>典型误用场景</th></tr></thead><tbody><tr><td><strong>Set</strong></td><td>是</td><td>否</td><td>O(1)</td><td>用SINTER计算超大集合</td></tr><tr><td><strong>ZSet</strong></td><td>是</td><td>是</td><td>O(logN)</td><td>Score精度丢失问题</td></tr><tr><td><strong>List</strong></td><td>否</td><td>插入序</td><td>O(N)</td><td>长列表LRANGE全量获取</td></tr></tbody></table><hr><p>建议结合具体业务场景练习数据类型组合使用，例如：</p><ul><li><strong>社交APP场景</strong>：用ZSet维护好友亲密度排行，Hash存储用户资料，Set管理共同好友</li><li><strong>电商系统场景</strong>：用String缓存商品详情，Hash存储购物车信息，ZSet实现销量排行榜</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis本质：内存型键值对数据库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本数据类型&lt;ul&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://example.com/tags/Redis/"/>
    
    <category term="数据库" scheme="https://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记</title>
    <link href="https://example.com/2025/02/25/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://example.com/2025/02/25/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-02-25T12:09:49.000Z</published>
    <updated>2025-02-25T12:21:42.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识TypeScript"><a href="#初识TypeScript" class="headerlink" title="初识TypeScript"></a>初识TypeScript</h2><p><a href="https://www.tslang.cn/">官网</a></p><p><strong>TypeScript</strong> 是由微软开发并维护的一种开源编程语言，它是 JavaScript 的超集，意味着所有的 JavaScript 代码都是合法的 TypeScript 代码。TypeScript 添加了静态类型检查和其他特性，旨在提高代码的可读性、可维护性和健壮性。</p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p>对于npm用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h2 id="基本类型与变量"><a href="#基本类型与变量" class="headerlink" title="基本类型与变量"></a>基本类型与变量</h2><p>与JavaScript不同，TypeScript在声明变量时可以通过注解来约束变量类型</p><p><strong>布尔值</strong></p><p>最基本的数据类型就是简单的true&#x2F;false值，在JavaScript和TypeScript里叫做<code>boolean</code>（其它语言中也一样）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><strong>数字</strong></p><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><p><strong>字符串</strong></p><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code>表示文本数据类型。 和JavaScript一样，可以使用双引号（ <code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;smith&quot;</span>;</span><br></pre></td></tr></table></figure><p>你还可以使用<em>模版字符串</em>，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ &#96;&#96;&#96;），并且以<code>$&#123; expr &#125;</code>这种形式嵌入表达式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><p>这与下面定义<code>sentence</code>的方式效果相同：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;.\n\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;I&#x27;ll be &quot;</span> + (age + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>元组 Tuple</strong></p><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><p>联合类型是高级主题，我们会在以后的章节里讨论它。</p><p><strong>枚举</strong></p><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code>开始编号：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure><p>或者，全部都采用手动赋值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span> = <span class="number">2</span>, <span class="title class_">Blue</span> = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure><p><strong>Any</strong></p><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure><p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 <code>Object</code>有相似的作用，就像它在其它语言中那样。 但是 <code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.<span class="title function_">ifItExists</span>(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.<span class="title function_">toFixed</span>(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">prettySure</span>: <span class="title class_">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.<span class="title function_">toFixed</span>(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure><p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>Void</strong></p><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p><strong>Null 和 Undefined</strong></p><p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和 <code>void</code>相似，它们的本身的类型用处不是很大：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p><p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。 这能避免 <em>很多</em>常见的问题。 也许在某处你想传入一个 <code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p><blockquote><p>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p></blockquote><p><strong>Never</strong></p><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p><p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使 <code>any</code>也不可以赋值给<code>never</code>。</p><p>下面是一些返回<code>never</code>类型的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params"><span class="attr">message</span>: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Object</strong></p><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p><p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"><span class="attr">o</span>: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><strong>类型断言</strong></p><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>另一个为<code>as</code>语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 <code>as</code>语法断言是被允许的。</p><h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初识TypeScript&quot;&gt;&lt;a href=&quot;#初识TypeScript&quot; class=&quot;headerlink&quot; title=&quot;初识TypeScript&quot;&gt;&lt;/a&gt;初识TypeScript&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.tslang.cn</summary>
      
    
    
    
    
    <category term="TypeScript" scheme="https://example.com/tags/TypeScript/"/>
    
  </entry>
  
</feed>
