<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TaoLe</title>
  
  
  <link href="https://example.com/atom.xml" rel="self"/>
  
  <link href="https://example.com/"/>
  <updated>2025-02-25T12:43:27.617Z</updated>
  <id>https://example.com/</id>
  
  <author>
    <name>taole</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LC_20250225</title>
    <link href="https://example.com/2025/02/25/LC-20250225/"/>
    <id>https://example.com/2025/02/25/LC-20250225/</id>
    <published>2025-02-25T12:43:27.000Z</published>
    <updated>2025-02-25T12:43:27.617Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis笔记整理</title>
    <link href="https://example.com/2025/02/25/Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>https://example.com/2025/02/25/Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2025-02-25T12:23:37.000Z</published>
    <updated>2025-02-25T12:48:37.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><p>Redis本质：内存型键值对数据库</p><ul><li>基本数据类型<ul><li>String</li><li>Hash</li><li>List</li><li>Set</li><li>ZSet</li><li>特殊类型</li></ul></li><li>持久化机制<ul><li>RDB（快照）</li><li>AOF（追加日志）</li></ul></li></ul><hr><h2 id="Redis基本数据类型"><a href="#Redis基本数据类型" class="headerlink" title="Redis基本数据类型"></a>Redis基本数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a><strong>String（字符串）</strong></h3><p>🔑 <strong>数据结构</strong><br>二进制安全，可存储文本&#x2F;数字&#x2F;序列化对象，最大512MB</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>SET key value [EX seconds]</code> 设置带过期时间的值</li><li><code>GET key</code> </li><li><code>INCR/DECR key</code> 原子计数器</li><li><code>MSET/MGET</code> 批量操作</li><li><code>SETBIT/GETBIT</code> 位操作</li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>缓存HTML片段&#x2F;序列化对象</li><li>分布式锁（SETNX）</li><li>限流器（INCR+EXPIRE）</li><li>位统计（日活用户Bitmap）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>Value超过10KB需警惕大Key问题</li><li>INCR存在溢出风险（最大值9223372036854775807）</li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>动态字符串SDS（O(1)获取长度，预分配空间）</li><li>数值类型自动转int存储优化</li></ul><hr><h3 id="Hash（哈希表）"><a href="#Hash（哈希表）" class="headerlink" title="Hash（哈希表）"></a><strong>Hash（哈希表）</strong></h3><p>🔑 <strong>数据结构</strong><br>双向链表，元素可重复，按插入顺序排序</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>LPUSH/RPUSH key element</code></li><li><code>LPOP/RPOP key</code></li><li><code>BLPOP/BRPOP</code> 阻塞式弹出</li><li><code>LRANGE key start stop</code></li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>消息队列（结合BLPOP实现）</li><li>最新消息排行（LPUSH+LRANGE）</li><li>分页查询（LRANGE实现）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>长列表（元素数&gt;1000）查询性能下降</li><li>多个消费者场景需做消息ACK确认</li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>快速链表quicklist（ziplist+linkedlist结合）</li><li>节点元素上限可通过list-max-ziplist-size配置</li></ul><p>📌 <strong>实战技巧</strong>  </p><ul><li>使用<code>LTRIM</code>维护固定长度队列</li></ul><hr><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><strong>List（列表）</strong></h3><p>🔑 <strong>数据结构</strong><br>双向链表，元素可重复，按插入顺序排序</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>LPUSH/RPUSH key element</code></li><li><code>LPOP/RPOP key</code></li><li><code>BLPOP/BRPOP</code> 阻塞式弹出</li><li><code>LRANGE key start stop</code></li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>消息队列（结合BLPOP实现）</li><li>最新消息排行（LPUSH+LRANGE）</li><li>分页查询（LRANGE实现）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>长列表（元素数&gt;1000）查询性能下降</li><li>多个消费者场景需做消息ACK确认</li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>快速链表quicklist（ziplist+linkedlist结合）</li><li>节点元素上限可通过list-max-ziplist-size配置</li></ul><p>📌 <strong>实战技巧</strong>  </p><ul><li>使用<code>LTRIM</code>维护固定长度队列</li></ul><hr><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a><strong>Set（集合）</strong></h3><p>🔑 <strong>数据结构</strong><br>无序且元素唯一的集合，支持交并差运算</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>SADD key member</code></li><li><code>SISMEMBER key member</code></li><li><code>SINTER key1 key2</code> 交集</li><li><code>SUNIONSTORE dest key1 key2</code> 并集存储</li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>标签系统（用户标签集合）</li><li>共同关注（SINTER计算交集）</li><li>UV统计（去重计数）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>SMEMBERS全量获取可能阻塞，优先用SSCAN</li><li>超大集合（&gt;1W元素）交并运算消耗内存激增</li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>小集合用intset（整数数组）</li><li>大集合转为hashtable存储</li></ul><p>📌 <strong>实战技巧</strong>  </p><ul><li>使用<code>SPOP</code>实现随机抽奖功能</li></ul><hr><h3 id="ZSet（有序集合）"><a href="#ZSet（有序集合）" class="headerlink" title="ZSet（有序集合）"></a><strong>ZSet（有序集合）</strong></h3><p>🔑 <strong>数据结构</strong><br>唯一成员+排序权重（score）的有序结构</p><p>💻 <strong>核心命令</strong>  </p><ul><li><code>ZADD key score member</code></li><li><code>ZRANGE key start stop [WITHSCORES]</code></li><li><code>ZRANK key member</code> 获取排名</li><li><code>ZREVRANGEBYSCORE</code> 按分数范围查询</li></ul><p>🎯 <strong>应用场景</strong>  </p><ul><li>实时排行榜（直播打赏排行）</li><li>延迟队列（score存执行时间戳）</li><li>范围查询（地理位置附近的人）</li></ul><p>⚠️ <strong>注意事项</strong>  </p><ul><li>Score使用双精度浮点数，存在精度丢失风险</li><li>大数据量范围查询优先用<code>ZSCAN</code></li></ul><p>🔧 <strong>底层原理</strong>  </p><ul><li>ziplist（元素数&lt;128且value&lt;64字节时）</li><li>skiplist+dict组合结构（跳跃表维护顺序，字典快速查找）</li></ul><p>📌 <strong>实战技巧</strong>  </p><ul><li>使用<code>ZUNIONSTORE</code>实现多维度加权排序</li></ul><hr><h3 id="数据类型选择决策树"><a href="#数据类型选择决策树" class="headerlink" title="数据类型选择决策树"></a><strong>数据类型选择决策树</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[需要排序?] --&gt;|Yes| B(ZSet)</span><br><span class="line">    A --&gt;|No| C&#123;需要唯一性?&#125;</span><br><span class="line">    C --&gt;|Yes| D(Set)</span><br><span class="line">    C --&gt;|No| E&#123;数据结构形态?&#125;</span><br><span class="line">    E --&gt;|Key-Value| F(Hash)</span><br><span class="line">    E --&gt;|单值/计数器| G(String)</span><br><span class="line">    E --&gt;|队列/栈| H(List)</span><br></pre></td></tr></table></figure><hr><h3 id="对比表"><a href="#对比表" class="headerlink" title="对比表"></a><strong>对比表</strong></h3><table><thead><tr><th></th><th>唯一性</th><th>排序</th><th>时间复杂度</th><th>典型误用场景</th></tr></thead><tbody><tr><td><strong>Set</strong></td><td>是</td><td>否</td><td>O(1)</td><td>用SINTER计算超大集合</td></tr><tr><td><strong>ZSet</strong></td><td>是</td><td>是</td><td>O(logN)</td><td>Score精度丢失问题</td></tr><tr><td><strong>List</strong></td><td>否</td><td>插入序</td><td>O(N)</td><td>长列表LRANGE全量获取</td></tr></tbody></table><hr><p>建议结合具体业务场景练习数据类型组合使用，例如：</p><ul><li><strong>社交APP场景</strong>：用ZSet维护好友亲密度排行，Hash存储用户资料，Set管理共同好友</li><li><strong>电商系统场景</strong>：用String缓存商品详情，Hash存储购物车信息，ZSet实现销量排行榜</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis本质：内存型键值对数据库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本数据类型&lt;ul&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://example.com/tags/Redis/"/>
    
    <category term="数据库" scheme="https://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记</title>
    <link href="https://example.com/2025/02/25/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://example.com/2025/02/25/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-02-25T12:09:49.000Z</published>
    <updated>2025-02-25T12:21:42.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识TypeScript"><a href="#初识TypeScript" class="headerlink" title="初识TypeScript"></a>初识TypeScript</h2><p><a href="https://www.tslang.cn/">官网</a></p><p><strong>TypeScript</strong> 是由微软开发并维护的一种开源编程语言，它是 JavaScript 的超集，意味着所有的 JavaScript 代码都是合法的 TypeScript 代码。TypeScript 添加了静态类型检查和其他特性，旨在提高代码的可读性、可维护性和健壮性。</p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p>对于npm用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h2 id="基本类型与变量"><a href="#基本类型与变量" class="headerlink" title="基本类型与变量"></a>基本类型与变量</h2><p>与JavaScript不同，TypeScript在声明变量时可以通过注解来约束变量类型</p><p><strong>布尔值</strong></p><p>最基本的数据类型就是简单的true&#x2F;false值，在JavaScript和TypeScript里叫做<code>boolean</code>（其它语言中也一样）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><strong>数字</strong></p><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><p><strong>字符串</strong></p><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code>表示文本数据类型。 和JavaScript一样，可以使用双引号（ <code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;smith&quot;</span>;</span><br></pre></td></tr></table></figure><p>你还可以使用<em>模版字符串</em>，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ &#96;&#96;&#96;），并且以<code>$&#123; expr &#125;</code>这种形式嵌入表达式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><p>这与下面定义<code>sentence</code>的方式效果相同：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;.\n\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;I&#x27;ll be &quot;</span> + (age + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>元组 Tuple</strong></p><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><p>联合类型是高级主题，我们会在以后的章节里讨论它。</p><p><strong>枚举</strong></p><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code>开始编号：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure><p>或者，全部都采用手动赋值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span> = <span class="number">2</span>, <span class="title class_">Blue</span> = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure><p><strong>Any</strong></p><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure><p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 <code>Object</code>有相似的作用，就像它在其它语言中那样。 但是 <code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.<span class="title function_">ifItExists</span>(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.<span class="title function_">toFixed</span>(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">prettySure</span>: <span class="title class_">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.<span class="title function_">toFixed</span>(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure><p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>Void</strong></p><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p><strong>Null 和 Undefined</strong></p><p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和 <code>void</code>相似，它们的本身的类型用处不是很大：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p><p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。 这能避免 <em>很多</em>常见的问题。 也许在某处你想传入一个 <code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p><blockquote><p>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p></blockquote><p><strong>Never</strong></p><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p><p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使 <code>any</code>也不可以赋值给<code>never</code>。</p><p>下面是一些返回<code>never</code>类型的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params"><span class="attr">message</span>: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Object</strong></p><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p><p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"><span class="attr">o</span>: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><strong>类型断言</strong></p><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>另一个为<code>as</code>语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 <code>as</code>语法断言是被允许的。</p><h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初识TypeScript&quot;&gt;&lt;a href=&quot;#初识TypeScript&quot; class=&quot;headerlink&quot; title=&quot;初识TypeScript&quot;&gt;&lt;/a&gt;初识TypeScript&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.tslang.cn</summary>
      
    
    
    
    
    <category term="TypeScript" scheme="https://example.com/tags/TypeScript/"/>
    
  </entry>
  
</feed>
